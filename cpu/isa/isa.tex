\documentclass[11pt,openany]{report}
\usepackage[margin=1in]{geometry}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\title{OSOROM Instruction Set Reference}
\author{The Moroso Project}
\setlength{\tabcolsep}{4pt}
\setcounter{tocdepth}{1}

\begin{document}
\lhead{The Moroso Project}
\chead{OSOROM Instruction Set Reference}
\rhead{v0.1}
\maketitle
\tableofcontents

\chapter{CPU Architecture}

\section{Instructions}
Each instruction is a 32-bit word, stored in little-endian order. The top 2 bits of the instruction select a predicate register, and the third bit from the top optionally inverts it. The instruction is only executed if the resulting predicate is true.



\section{Registers}
There are 32 32-bit general-purpose registers, R0 through R31. R31 is used as the link register for BL instructions. The program counter is stored separately, and may only be modified through branch instructions and read through BL instructions. 

There are three one-bit predicate registers, P0 through P2, that may be written to by compare instructions. A fourth predicate register, P3, is always true. Instructions predicated on P3 will always execute, and writes to P3 are ignored.

\section{ALU Instruction Formats}

ALU instructions may accept immediate values for one of their input operands, which come in two forms: Short immediates are embedded in the instruction and consist of a 10-bit constant and a 4-bit rotate amount. To achieve any even rotation between 0 and 30, the rotate amount is first multiplied by 2, and the constant is rotated right by the result. ALU instructions that accept a single operand use the portion of the instruction normally used for the other operand register to extend the constant to 15 bits. Long immediate operands are 32 bit values, and occupy the memory word following the instruction.

If a register is used as the last source operand of an ALU instruction, it may optionally be shifted by a 5-bit immediate value, as specified with the \texttt{SHF} and \texttt{SHIFTAMT} fields of the instruction. The \texttt{SHIFTAMT} field is the amount to shift, between 0 and 31, and the \texttt{SHF} field specifies the shift type, as follows:

\begin{table}[!h]
\centering
\begin{tabular}{l|l|l}
Encoding & Mnemonic & Shift Type\\
\hline
0 0 & \texttt{LSL} & Logical Shift Left \\ 
0 1 & \texttt{LSR} & Logical Shift Right \\ 
1 0 & \texttt{ASR} & Arithmetic Shift Right \\ 
1 1 & \texttt{ROR} & Rotate Right
\end{tabular}
\end{table}

ALU instructions taking a single operand may also specify a register shifted by an unsigned value contained in another register \texttt{Rt}. In this case, the same \texttt{SHF} types are available. If the value of the shift register is greater than 31, the following behavior is used: Logical shifts zero the result, arithmetic right shift extends the sign bit of the operand register across the entire result, and rotate rotates the value by \texttt{Rt \% 32}.

\section{VLIW}
At each time step, the CPU fetches a ``packet'' of 4 instructions located contiguously in memory and executes them in parallel. These packets must be aligned to their 16-byte size, and branch targets must also be so aligned.

There are three types of instructions: Control, Memory, and ALU instructions. Only one control instruction may be executed in any given packet; it must occupy the first (lowest-address) slot in its packet. Likewise, only the first two slots in a packet may execute memory instructions. ALU instructions may be located in any slot.

If a long immediate operand is specified for an ALU instruction, the following slot is interpreted as an operand and no operation is issued for that slot. The final slot in a packet may not specify a long immediate operand.


\section{Virtual Memory}
Virtual memory is accomplished through a hardware-filled TLB, with 4KB pages and a 2-level page-table structure. Page directories and page tables are one page in size, containing 1024 32-bit entries. Virtual addresses are 32 bits and are broken up into 3 parts: Page Directory Index, Page Table Index, and Page Offset, as follows:

\begin{table}[!h]
\centering
\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & & & & & & & & & 2 & 2 & & & & & & & & & 1 & 1 & & & & & & & & & & &\\
	1 & & & & & & & & & 2 & 1 & & & & & & & & & 2 & 1 & & & & & & & & & & & 0\\
	\hline
	\multicolumn{10}{|c}{PD INDEX} & \multicolumn{10}{|c|}{PT INDEX} & \multicolumn{12}{c|}{OFFSET}\\
	\hline
\end{tabular}
}
\end{table}

The page directory base is stored in a coprocessor register, \texttt{PTBR}. Writes to this register will flush all entries not marked global from the TLB.
Page table entries and page directory entries are each 32 bits and have the same format:

\begin{table}[!h]
\centering
\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & & 2 & 2 & & & & & & & & & & & & & & & & 1 & 1 & & & & & & & & & & &\\
	1 & & 9 & 8 & & & & & & & & & & & & & & & & 2 & 1 & & & & & & & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c}{RSV} & \multicolumn{17}{|c|}{PHYSICAL PAGE BASE} & \multicolumn{8}{c|}{UNUSED} & G & \multicolumn{1}{|c|}{K} & W & \multicolumn{1}{|c|}{P}\\
	\hline
\end{tabular}
}
\end{table}

The four flags in each entry have the following meanings:

\begin{itemize}
  \item \texttt{G}: Global page. Mappings with this bit set in either level will not be flushed from the TLB when the page table base register is modified.
  \item \texttt{K}: Kernel-only page. Mappings with this bit set in either level may only be read or written to while the processor is in kernel mode. Attempting to access such mappings from user mode will generate a page fault exception.
  \item \texttt{W}: Writeable page. Attempting to write to a page without this bit set in both levels will result in a page fault.
  \item \texttt{P}: Present. Attempting to access a page without this bit set in both levels will result in a page fault.
\end{itemize}

Since our FPGA has 512MB of physical memory, physical page bases are 17 bits, and offsets are 12 bits. The top bits of an entry are not used but should remain 0 in case we go to 32-bit physical addresses in the future. Bits 11 through 4 are free for programmer use.

\section{Exceptions}

\chapter{Instruction Listing}

\pagebreak
\section{ADD - Addition}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 0 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 0 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 0 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!ADD[PN] Rd, Rs, #Imm!
  \item \verb!ADD[PN] Rd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
ADD is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
Adds the two operands together into the destination register. If two register operands are specified, the second may optionally be shifted by an immediate value before the addition is performed.

TODO optional overflow exceptions???

\pagebreak
\section{AND - Bitwise And}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 0 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 0 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & \\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 0 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!AND[PN] Rd, Rs, #Imm!
  \item \verb!AND[PN] Rd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
AND is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
Computes the bitwise logical AND of the two operands, storing the result in the destination register. If two register operands are specified, the second may optionally be shifted by an immediate value before the computation is performed.

\pagebreak
\section{B - Branch}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 1 & 0 & 0 & \multicolumn{25}{|c|}{OFFSET}\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 1 & 1 & 0 & \multicolumn{20}{|c|}{OFFSET} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!B[PN] <label>!
  \item \verb!B[PN] (Rs + OFF)!
\end{itemize}

\subsection{Type}
Branch is a Control operation. It may only be placed as the first instruction in a packet.

\subsection{Behavior}
Transfers control to the address specified. The \texttt{OFFSET} field is shifted left by 4 places and sign-extended to 32 bits, then added to either the source register or, if none is specified, the address of the branch instruction. If the specified base register is not aligned to a 16-byte value, the target is rounded down to the nearest aligned value before control is transferred. Other instructions in the same packet as the branch instruction are executed before control is transferred.


\pagebreak
\section{BL - Branch with Link}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 1 & 0 & 1 & \multicolumn{25}{|c|}{OFFSET}\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 1 & 1 & 1 & \multicolumn{20}{|c|}{OFFSET} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!BL[PN] <label>!
  \item \verb!BL[PN] (Rs + OFF)!
\end{itemize}

\subsection{Type}
Branch with Link is a Control operation. It may only be placed as the first instruction in a packet.

\subsection{Behavior}
BL functions identically to the Branch instruction, except that the address of the BL instruction is placed in R31.

\pagebreak
\section{BREAK - TODO XXX}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & \multicolumn{1}{|c}{X} & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & \multicolumn{1}{c|}{X} \\
	\hline
\end{tabular}
}

\pagebreak
\section{CMPBC - Compare Bits Clear}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 1 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 1 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 1 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!CMPBC[PN] Pd, Rs, #Imm!
  \item \verb!CMPBC[PN] Pd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
CMPBC is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
CMPBC checks each bit of Rs corresponding to a 1 bit in the second operand, writing 1 into the destination predicate if all such bits are 0, and writing 0 otherwise -- that is, it computes the unary OR of the bits in \verb!(~Rs & OP2)! and stores the result in the desired predicate.

\noindent
P3 is pinned to 1. Writes into P3 from compare instructions are ignored.

\pagebreak
\section{CMPBS - Compare Bits Set}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 1 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 1 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 1 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!CMPBS[PN] Pd, Rs, #Imm!
  \item \verb!CMPBS[PN] Pd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
CMPBS is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
CMPBS checks each bit of Rs corresponding to a 1 bit in the second operand, writing 1 into the destination predicate if any such bit is 1, and writing 0 otherwise  -- that is, it computes the unary OR of the bits in \verb!(Rs & OP2)! and stores the result in the desired predicate.

\noindent
P3 is pinned to 1. Writes into P3 from compare instructions are ignored.

\pagebreak
\section{CMPEQ - Compare Equal}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 1 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 1 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 1 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!CMPEQ[PN] Pd, Rs, #Imm!
  \item \verb!CMPEQ[PN] Pd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
CMPEQ is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
CMPEQ tests whether its two operands are equal, writing 1 into the destination predicate if they are and 0 otherwise.

\noindent
P3 is pinned to 1. Writes into P3 from compare instructions are ignored.


\pagebreak
\section{CMPLES - Compare Less Than or Equal (Signed)}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 0 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 0 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 0 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!CMPLES[PN] Pd, Rs, #Imm!
  \item \verb!CMPLES[PN] Pd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
CMPLES is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
CMPLES interprets its operands as 32-bit two's-complement signed integers, and writes 1 into the specified predicate register if the value of \texttt{Rs} is less than or equal to the value of the second operand, and 0 otherwise.

\noindent
P3 is pinned to 1. Writes into P3 from compare instructions are ignored.


\pagebreak
\section{CMPLEU - Compare Less Than or Equal (Unsigned)}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 0 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 0 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 0 & 1 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!CMPLEU[PN] Pd, Rs, #Imm!
  \item \verb!CMPLEU[PN] Pd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
CMPLEU is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
CMPLEU interprets its operands as 32-bit unsigned integers, and writes 1 into the specified predicate register if the value of \texttt{Rs} is less than or equal to the value of the second operand, and 0 otherwise.

\noindent
P3 is pinned to 1. Writes into P3 from compare instructions are ignored.


\pagebreak
\section{CMPLTS - Compare Less Than (Signed)}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 0 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 0 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{1} & 0 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!CMPLTS[PN] Pd, Rs, #Imm!
  \item \verb!CMPLTS[PN] Pd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
CMPLTS is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
CMPLTS interprets its operands as 32-bit two's-complement signed integers, and writes 1 into the specified predicate register if the value of \texttt{Rs} is less than to the value of the second operand, and 0 otherwise.

\noindent
P3 is pinned to 1. Writes into P3 from compare instructions are ignored.


\pagebreak
\section{CMPLTU - Compare Less Than (Unsigned)}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 0 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 0 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{0} & 0 & 0 & \multicolumn{2}{|c}{PD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!CMPLTU[PN] Pd, Rs, #Imm!
  \item \verb!CMPLTU[PN] Pd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
CMPLTU is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
CMPLTU interprets its operands as 32-bit unsigned integers, and writes 1 into the specified predicate register if the value of \texttt{Rs} is less than to the value of the second operand, and 0 otherwise.

\noindent
P3 is pinned to 1. Writes into P3 from compare instructions are ignored.



\pagebreak
\section{DIV - Integer Division}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & \multicolumn{1}{|c}{X} & \multicolumn{5}{|c|}{RT} & X & X & X & X & \multicolumn{5}{|c|}{RD} & \multicolumn{5}{c|}{RS} \\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!DIV[PN] Rd, Rs, Rt!
\end{itemize}

\subsection{Type}

DIV is a Control operation. It may only be placed as the first instruction in a packet.

\subsection{Behavior}

Performs the integer division \texttt{Rs / Rt}, writing the quotient into \texttt{Rd} and the remainder into the multiply/divide overflow register.


\pagebreak
\section{ERET - Return from Exception}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & \multicolumn{1}{|c}{X} & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & \multicolumn{1}{c|}{X} \\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!ERET[PN]!
\end{itemize}

\subsection{Type}

ERET is a Control operation. It may only be placed as the first instruction in a packet. It may only be used when the processor is in kernel mode.

\subsection{Behavior}
ERET returns the processor to user mode from kernel mode, and branches to the memory address contained in the Error PC control register. Other instructions in the same packet as the ERET instruction are executed in kernel mode before control is transferred. This instruction also clears the memory link bit. 


\pagebreak
\section{FENCE}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & \multicolumn{1}{|c}{X} & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & \multicolumn{1}{c|}{X} \\
	\hline
\end{tabular}
}

\subsection{Syntax}
\begin{itemize}
  \item \verb!FENCE[PN]!
\end{itemize}

\subsection{Type}
FENCE is a Control operation. It may only be placed as the first instruction in a packet.

\subsection{Behavior}
Our architecture doesn't reorder requests, so right now FENCE is a no-op. If we have to add behavior to it in the future, memory instructions in the same packet as the FENCE will probably go after it, but please don't count on that right now.

\pagebreak
\section{FLUSH - Flush L1 Caches}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & \multicolumn{1}{|c|}{C} & X & X & X & X & X & X & X & \multicolumn{2}{|c|}{TYPE} & X & X & X & X & X & \multicolumn{5}{|c|}{RS} \\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!FLUSH[PN] TYPE, Rs!
\end{itemize}

\subsection{Type}

FLUSH is a Control operation. It may only be placed as the first instruction in a packet.

\subsection{Behavior}

FLUSH invalidates the line in the specified L1 cache corresponding to the virtual address contained in \texttt{Rs}. For instruction or data cache flushes, attempting to flush a virtual address whose
access would cause a page fault will also cause a page fault. If a dirty data cache line is flushed, the new value is immediately written out to the L2 cache, where it will be visible to DMA peripherals.

\noindent
Values for the \texttt{TYPE} field are as follows:

\begin{table}[!h]
\centering
\begin{tabular}{l|l|l}
  Value & Mnemonic & Type\\
  \hline
  0 0 & \texttt{DATA} & L1 Data Cache\\
  0 1 & \texttt{INST} & L1 Instruction Cache\\
  1 0 & \texttt{DTLB} & Data TLB\\
  1 1 & \texttt{ITLB} & Instruction TLB
\end{tabular}
\end{table}


\pagebreak
\section{LB - Load Byte}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 1 & \multicolumn{12}{|c|}{OFFSET} & 0 & 0 & 0 & \multicolumn{5}{|c|}{RD} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!LB[PN] Rd, (Rs [+ OFFSET])!
\end{itemize}

\subsection{Type}
LB is a Memory operation. It may only be placed in the first or second slot in an instruction packet.

\subsection{Behavior}
LB loads a byte from the specified address into \texttt{Rd}. The address is computed by sign-extending the \texttt{OFFSET} field to 32 bits and adding it to the value of \texttt{Rs}. The high 24 bits of \texttt{Rd} are zeroed.


\pagebreak
\section{LH - Load Half-Word}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 1 & \multicolumn{12}{|c|}{OFFSET} & 0 & 0 & 1 & \multicolumn{5}{|c|}{RD} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!LH[PN] Rd, (Rs [+ OFFSET])!
\end{itemize}

\subsection{Type}
LH is a Memory operation. It may only be placed in the first or second slot in an instruction packet.

\subsection{Behavior}
LH loads two bytes from the specified address into \texttt{Rd}. The address is computed by sign-extending the \texttt{OFFSET} field to 32 bits and adding it to the value of \texttt{Rs}. Only 2-byte aligned addresses may be accessed - the low bit of the address is ignored. The high 16 bits of \texttt{Rd} are zeroed.


\pagebreak
\section{LL - Load Linked}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 1 & \multicolumn{12}{|c|}{OFFSET} & 0 & 1 & 1 & \multicolumn{5}{|c|}{RD} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!LL[PN] Rd, (Rs [+ OFFSET])!
\end{itemize}

\subsection{Type}
LL is a Memory operation. It may only be placed in the first or second slot in an instruction packet.

\subsection{Behavior}
LL loads a word from the specified address into \texttt{Rd}. The address is computed by sign-extending the \texttt{OFFSET} field to 32 bits and adding it to the value of \texttt{Rs}. Only 4-byte aligned addresses may be accessed - the low 2 bits of the address are ignored.

\noindent
Additionally, LL sets the link bit. A future SC operation will only complete if no interrupt, exception, or ERET clears the link bit in the intervening period.


\pagebreak
\section{LW - Load Word}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 1 & \multicolumn{12}{|c|}{OFFSET} & 0 & 1 & 0 & \multicolumn{5}{|c|}{RD} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!LW[PN] Rd, (Rs [+ OFFSET])!
\end{itemize}

\subsection{Type}
LW is a Memory operation. It may only be placed in the first or second slot in an instruction packet.

\subsection{Behavior}
LW loads a word from the specified address into \texttt{Rd}. The address is computed by sign-extending the \texttt{OFFSET} field to 32 bits and adding it to the value of \texttt{Rs}. Only 4-byte aligned addresses may be accessed - the low 2 bits of the address are ignored.


\pagebreak
\section{MFC - Move From Coprocessor Register}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 0 & \multicolumn{1}{|c}{X} & X & X & X & X & X & X & X & X & X & \multicolumn{5}{|c|}{RD} & \multicolumn{5}{c|}{CPRS} \\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!MFC[PN] Rd, CPRs!
\end{itemize}

\subsection{Type}
MFC is a Control operation. It may only be placed as the first instruction in a packet. It may only be used when the processor is in kernel mode.

\subsection{Behavior}
MFC moves the contents of the specfied coprocessor register into the specified general-purpose register. See TODO XXX Link for a description of the available coprocessor registers and their mnemonics.


\pagebreak
\section{MFHI - Move From Multiply/Division Overflow Register}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{X} & X & X & X & X & X & X & X & X & X & \multicolumn{5}{|c|}{RD} & X & X & X & X & \multicolumn{1}{c|}{X}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!MFHI[PN] Rd!
\end{itemize}

\subsection{Type}
MFHI is a Control operation. It may only be placed as the first instruction in a packet.

\subsection{Behavior}
MFHI moves the contents of the multiply/division overflow register into the specified general-purpose register. This register stores the high bits of results of multiplication operations, or the remainders generated by division operations.

\pagebreak
\section{MOV - Move}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTLOW} & \multicolumn{4}{|c|}{ROTATE} & 1 & 0 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{CONSTHI} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c|}{SHF} & X & X & X & X &\multicolumn{1}{c|}{X} & 1 & 0 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \multicolumn{2}{|c|}{SHF} & \multicolumn{5}{c|}{RT} & 1 & 0 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 1 & 0 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!MOV[PN] Rd, #Imm!
  \item \verb!MOV[PN] Rd, Rs [SHF #Imm]!
  \item \verb!MOV[PN] Rd, Rs SHF Rt!
\end{itemize}

\subsection{Type}
MOV is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
MOV moves the value of its source operand into the specified destination register. If the second operand is a register, it may be shifted by an immediate value or by the contents of a register before being stored.

\pagebreak
\section{MTC - Move To Coprocessor Register}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{X} & X & X & X & X & X & X & X & X & X & \multicolumn{5}{|c|}{CPRD} & \multicolumn{5}{c|}{RS} \\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!MTC[PN] CPRd, Rs!
\end{itemize}

\subsection{Type}
MTC is a Control operation. It may only be placed as the first instruction in a packet. It may only be used when the processor is in kernel mode.

\subsection{Behavior}
MTC moves the contents of the selected general-purpose register into the specified coprocessor register. See TODO XXX Link for a description of the available coprocessor registers and their mnemonics.


\pagebreak
\section{MTHI - Move To Multiply/Division Overflow Register}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 1 & \multicolumn{1}{|c}{X} & X & X & X & X & X & X & X & X & X & X & X & X & X& X & \multicolumn{5}{|c|}{RS} \\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!MTHI[PN] Rs!
\end{itemize}

\subsection{Type}
MTHI is a Control operation. It may only be placed as the first instruction in a packet.

\subsection{Behavior}
MTHI moves the value of the specified general-purpose register into the multiply/division overflow register.

\pagebreak
\section{MVN - Move and Invert}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTLOW} & \multicolumn{4}{|c|}{ROTATE} & 1 & 0 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{CONSTHI} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c|}{SHF} & X & X & X & X &\multicolumn{1}{c|}{X} & 1 & 0 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \multicolumn{2}{|c|}{SHF} & \multicolumn{5}{c|}{RT} & 1 & 0 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 1 & 0 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!MVN[PN] Rd, #Imm!
  \item \verb!MVN[PN] Rd, Rs [SHF #Imm]!
  \item \verb!MVN[PN] Rd, Rs SHF Rt!
\end{itemize}

\subsection{Type}
MVN is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
MVN inverts its source operand, storing the result in the specified destination register. If the second operand is a register, it may be shifted by an immediate value or by the contents of a register before being inverted and stored.


\pagebreak
\section{MULT - Integer Multiplication}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & \multicolumn{1}{|c}{S} & \multicolumn{5}{|c|}{RT} & X & X & X & X & \multicolumn{5}{|c|}{RD} & \multicolumn{5}{c|}{RS} \\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!MULT[PN] Rd, Rs, Rt!
  \item \verb!MULTS[PN] Rd, Rs, Rt!
\end{itemize}

\subsection{Type}
MULT is a Control operation. It may only be placed as the first instruction in a packet.

\subsection{Behavior}
MULT performs an integer multiplication on its two register operands. If the S bit is set, the operands are interpreted as two's complement signed integers; otherwise they are interpreted as unsigned. The low 32 bits of the 64 bit result are placed in the specified destination register, and the high 32 bits are placed in the special-purpose multiply/division overflow register, where they are accessible via the MFHI instruction.


\pagebreak
\section{NOR - Bitwise Logical NOR}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 0 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 0 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 0 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!NOR[PN] Rd, Rs, #Imm!
  \item \verb!NOR[PN] Rd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
NOR is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
Computes the bitwise logical NOR of the two operands, storing the result in the destination register. If two register operands are specified, the second may optionally be shifted by an immediate value before the computation is performed.


\pagebreak
\section{OR - Bitwise Logical OR}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 0 & 1 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 0 & 1 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & \\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 0 & 1 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM \\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!OR[PN] Rd, Rs, #Imm!
  \item \verb!OR[PN] Rd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
OR is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
Computes the bitwise logical OR of the two operands, storing the result in the destination register. If two register operands are specified, the second may optionally be shifted by an immediate value before the computation is performed.


\pagebreak
\section{RSB - Reverse Subtraction}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & \\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!RSB[PN] Rd, Rs, #Imm!
  \item \verb!RSB[PN] Rd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
RSB is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
Subtracts the value stored in RS from the value of the second operand, storing the result in the destination register. If two register operands are specified, the second may optionally be shifted by an immediate value before the computation is performed.


\pagebreak
\section{SB - Store Byte}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 1 & \multicolumn{6}{|c|}{OFFSETHIGH} & \multicolumn{5}{c}{RT} & \multicolumn{1}{|c|}{M} & 1 & 0 & 0 & \multicolumn{5}{|c|}{OFFSETLOW} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!SB[PN] Rt, (Rs [+ OFFSET])!
\end{itemize}

\subsection{Type}
SB is a Memory operation. It may only be placed in the first or second slot in an instruction packet.

\subsection{Behavior}
SB stores the low byte of \texttt{Rt} at the provided address. The address is computed by sign-extending the \texttt{OFFSET} field to 32 bits and adding it to the value of \texttt{Rs}. 

\noindent
The \texttt{OFFSET} field for stores is broken up into 3 parts: \verb#{inst[24:19], inst[13], inst[9:5]}#.


\pagebreak
\section{SC - Store Conditional}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 1 & \multicolumn{6}{|c|}{OFFSETHIGH} & \multicolumn{5}{c}{RT} & \multicolumn{1}{|c|}{M} & 1 & 1 & 1 & \multicolumn{5}{|c|}{OFFSETLOW} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!SC[PN] Rt, (Rs [+ OFFSET])!
\end{itemize}

\subsection{Type}
SC is a Memory operation. It may only be placed in the first or second slot in an instruction packet.

\subsection{Behavior}
SC stores the value in \texttt{Rt} at the provided address, if the processor's link bit is set. The address is computed by sign-extending the \texttt{OFFSET} field to 32 bits and adding it to the value of \texttt{Rs}. Only 4-byte aligned addresses may be accessed - the low 2 bits of the address are ignored.

The link bit is set by executing the LL instruction, and is cleared by the SC or ERET instructions, or any time an exception or interrupt is dispatched. SC only completes if the link bit is set when it is executed - thus, if it completes, all instructions since the last LL instruction are known to have been executed atomically. The SC instruction writes a 1 into predicate register 0 if the store completes successfully, or a 0 if it fails.

The \texttt{OFFSET} field for stores is broken up into 3 parts: \verb#{inst[24:19], inst[13], inst[9:5]}#.




\pagebreak
\section{SH - Store Half-Word}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 1 & \multicolumn{6}{|c|}{OFFSETHIGH} & \multicolumn{5}{c}{RT} & \multicolumn{1}{|c|}{M} & 1 & 0 & 1 & \multicolumn{5}{|c|}{OFFSETLOW} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!SH[PN] Rt, (Rs [+ OFFSET])!
\end{itemize}

\subsection{Type}
SH is a Memory operation. It may only be placed in the first or second slot in an instruction packet.

\subsection{Behavior}
SH stores the low two bytes of \texttt{Rt} at the provided address. The address is computed by sign-extending the \texttt{OFFSET} field to 32 bits and adding it to the value of \texttt{Rs}. The address must be aligned to a multiple of 2; the low bit of the address is ignored.

\noindent
The \texttt{OFFSET} field for stores is broken up into 3 parts: \verb#{inst[24:19], inst[13], inst[9:5]}#.


\pagebreak
\section{SUB - Subtraction}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 0 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!SUB[PN] Rd, Rs, #Imm!
  \item \verb!SUB[PN] Rd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
SUB is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
Subtracts the value of the second operand from the value in \texttt{Rs}, storing the result in the destination register. If two register operands are specified, the second may optionally be shifted by an immediate value before the computation is performed.


\pagebreak
\section{SW - Store Word}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 1 & \multicolumn{6}{|c|}{OFFSETHIGH} & \multicolumn{5}{c}{RT} & \multicolumn{1}{|c|}{M} & 1 & 1 & 0 & \multicolumn{5}{|c|}{OFFSETLOW} & \multicolumn{5}{c|}{RS}\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!SW[PN] Rt, (Rs [+ OFFSET])!
\end{itemize}

\subsection{Type}
SW is a Memory operation. It may only be placed in the first or second slot in an instruction packet.

\subsection{Behavior}
SW stores the contents of \texttt{Rt} at the provided address. The address is computed by sign-extending the \texttt{OFFSET} field to 32 bits and adding it to the value of \texttt{Rs}. The address must be aligned to a multiple of 4; the low two bits of the address are ignored.

\noindent
The \texttt{OFFSET} field for stores is broken up into 3 parts: \verb#{inst[24:19], inst[13], inst[9:5]}#.


\pagebreak
\section{SXB - Sign-Extend Byte}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTLOW} & \multicolumn{4}{|c|}{ROTATE} & 1 & 0 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{CONSTHI} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c|}{SHF} & X & X & X & X &\multicolumn{1}{c|}{X} & 1 & 0 & 0 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \multicolumn{2}{|c|}{SHF} & \multicolumn{5}{c|}{RT} & 1 & 0 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 1 & 0 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!SXB[PN] Rd, #Imm!
  \item \verb!SXB[PN] Rd, Rs [SHF #Imm]!
  \item \verb!SXB[PN] Rd, Rs SHF Rt!
\end{itemize}

\subsection{Type}
SXB is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
SXB moves the low byte of its source operand into the specified destination register, sign-extending it across the rest of the register. If the second operand is a register, it may be shifted by an immediate value or by the contents of a register before being stored.


\pagebreak
\section{SXH - Sign-Extend Half-Word}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTLOW} & \multicolumn{4}{|c|}{ROTATE} & 1 & 0 & 1 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{CONSTHI} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c|}{SHF} & X & X & X & X &\multicolumn{1}{c|}{X} & 1 & 0 & 1 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & \multicolumn{2}{|c|}{SHF} & \multicolumn{5}{c|}{RT} & 1 & 0 & 1 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 1 & 0 & 1 & 1 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!SXH[PN] Rd, #Imm!
  \item \verb!SXH[PN] Rd, Rs [SHF #Imm]!
  \item \verb!SXH[PN] Rd, Rs SHF Rt!
\end{itemize}

\subsection{Type}
SXH is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
SXH moves the low two bytes of its source operand into the specified destination register, sign-extending it across the rest of the register. If the second operand is a register, it may be shifted by an immediate value or by the contents of a register before being stored.


\pagebreak
\section{SYSCALL - TODO XXX}

\subsection{Encoding}

\texttt{%
\begin{tabular}{cccccccccccccccccccccccccccccccc}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & \\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0\\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & \multicolumn{1}{|c}{X} & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & X & \multicolumn{1}{c|}{X} \\
	\hline
\end{tabular}
}

\pagebreak
\section{XOR - Bitwise Exclusive OR}

\subsection{Encoding}

\texttt{%
\begin{tabular}{ccccccccccccccccccccccccccccccccl}
	3 & 3 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & & & & & & & & & & &\\
	1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2 & 1 & 0 & \\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 0 & \multicolumn{10}{|c}{CONSTANT} & \multicolumn{4}{|c|}{ROTATE} & 0 & 1 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} &\\
	\cline{1-32}
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 1 & \multicolumn{5}{|c}{SHIFTAMT} & \multicolumn{2}{|c}{SHF} & \multicolumn{5}{|c|}{RT} & 0 & 1 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & \\
	\hline
	\multicolumn{3}{|c|}{PRED} & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \multicolumn{1}{c|}{0} & 0 & 1 & 1 & 0 & \multicolumn{5}{|c}{RD} & \multicolumn{5}{|c|}{RS} & LIM\\
	\hline
\end{tabular}
}

\subsection{Syntax}

\begin{itemize}
  \item \verb!XOR[PN] Rd, Rs, #Imm!
  \item \verb!XOR[PN] Rd, Rs, Rt [SHF #Imm]!
\end{itemize}

\subsection{Type}
XOR is an ALU operation. It may be placed in any slot of a packet. If the long immediate form is used it must not be located in the last slot in a packet, and no instruction may be specified in the following slot.

\subsection{Behavior}
Computes the bitwise logical XOR of the two operands, storing the result in the destination register. If two register operands are specified, the second may optionally be shifted by an immediate value before the computation is performed.


\end{document}
